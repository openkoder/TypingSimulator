class Solution {
public:
	// Функция для подсчета количества магических квадратов 3x3 в заданной сетке
	int numMagicSquaresInside(vector<vector<int>>& grid) {
		int count = 0;  // Инициализируем счетчик магических квадратов
		int m = grid.size();  // Получаем количество строк в сетке
		int n = grid[0].size();  // Получаем количество столбцов в сетке
		
		// Проходим по всем возможным подматрицам 3x3 в сетке
		for (int i = 0; i < m - 2; i++) {  // Проход по строкам до m-2, чтобы не выйти за пределы
			for (int j = 0; j < n - 2; j++) {  // Проход по столбцам до n-2, чтобы не выйти за пределы
				// Проверяем, является ли подматрица 3x3 с верхним левым углом в (i, j) магическим квадратом
				if (isMagicSquare(grid, i, j)) {
					count++;  // Если да, увеличиваем счетчик магических квадратов
				}
			}
		}
		
		return count;  // Возвращаем общее количество найденных магических квадратов
	}

private:
	// Функция для проверки, является ли подматрица 3x3, начиная с (i, j), магическим квадратом
	bool isMagicSquare(vector<vector<int>>& grid, int i, int j) {
		// Инициализируем вектор 'nums' размером 9, все элементы установлены в 0. Этот вектор будет использоваться для отслеживания, какие числа от 1 до 9 уже встречались в подматрице
		vector<int> nums(9, 0);

		// Проходим по подматрице 3x3
		for (int x = i; x < i + 3; x++) {  // Проход по строкам подматрицы
			for (int y = j; y < j + 3; y++) {  // Проход по столбцам подматрицы
				// Проверяем, является ли текущий элемент допустимым (в диапазоне от 1 до 9) и не был ли он уже встречен ранее (проверяется вектором nums)
				if (grid[x][y] < 1 || grid[x][y] > 9 || nums[grid[x][y] - 1] == 1) {
					// Если элемент недопустим или уже был встречен, возвращаем false, так как это не магический квадрат
					return false;
				}

				// Отмечаем текущий элемент как встреченный, установив соответствующий
				// элемент вектора 'nums' в 1
				nums[grid[x][y] - 1] = 1;
			}
		}

		// Вычисляем целевую сумму для строк, столбцов и диагоналей
		// суммируя первые три элемента в первой строке
		int target = grid[i][j] + grid[i][j + 1] + grid[i][j + 2];
		
		// Проверяем строки
		for (int x = i; x < i + 3; x++) {  // Проход по строкам подматрицы
				int sum = 0;  // Инициализируем сумму для текущей строки
				for (int y = j; y < j + 3; y++) {  // Проход по каждому элементу строки
						sum += grid[x][y];  // Суммируем элементы строки
				}
				if (sum != target) {  // Если сумма строки не равна целевой сумме, возвращаем false
						return false;
				}
		}
		
		// Проверяем столбцы
		for (int y = j; y < j + 3; y++) {  // Проход по столбцам подматрицы
				int sum = 0;  // Инициализируем сумму для текущего столбца
				for (int x = i; x < i + 3; x++) {  // Проход по каждому элементу столбца
						sum += grid[x][y];  // Суммируем элементы столбца
				}
				if (sum != target) {  // Если сумма столбца не равна целевой сумме, возвращаем false
						return false;
				}
		}
		
		// Проверяем диагонали
		int sum1 = 0, sum2 = 0;
		for (int k = 0; k < 3; k++) {
				sum1 += grid[i + k][j + k];
				sum2 += grid[i + k][j + 2 - k];
		}
		if (sum1 != target || sum2 != target) {
				return false;
		}
		
		return true;
	}
};
